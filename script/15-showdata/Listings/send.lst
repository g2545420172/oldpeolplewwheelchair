C51 COMPILER V9.60.0.0   SEND                                                              09/06/2020 19:18:49 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SEND
OBJECT MODULE PLACED IN .\Objects\send.obj
COMPILER INVOKED BY: D:\APP\Keil\C51\BIN\C51.EXE app\send.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\app) DEBUG OBJECTEXTEND PR
                    -INT(.\Listings\send.lst) OBJECT(.\Objects\send.obj)

line level    source

   1          /***
   2          串口控制发送函数
   3          ***/
   4          #include "reg51.h"
   5          #include "intrins.h"
   6          #include "send.h"
   7          
   8          typedef unsigned char BYTE;
   9          typedef unsigned int WORD;
  10          
  11          #define FOSC 11059200L          //系统频率
  12          #define BAUD 9600             //串口波特率
  13          
  14          sfr AUXR  = 0x8e;               //辅助寄存器
  15          
  16          sfr P_SW1   = 0xA2;             //外设功能切换寄存器1
  17          
  18          #define S1_S0 0x40              //P_SW1.6
  19          #define S1_S1 0x80              //P_SW1.7
  20          
  21          bit busy;
  22          
  23          
  24          /*串口初始化*/
  25          void uInit()
  26          {
  27   1              //ACC 是一个累加器，主要用来存放数据
  28   1              ACC = P_SW1;
  29   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
  30   1              //P_SW1是一个特殊功能的寄存器，用来将串口1进行切换
  31   1          P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
  32   1              // 串行控制器SCON为01010000
  33   1              //SM0为0 SM1为1 说明工作方式为方式1 8位UART，波特率可变
  34   1              //SM2为0 说明不是多机通信
  35   1              //REN为1 允许串行接收
  36   1              //TB8为0 在方式2或3中表示发送的第9位数据，我们用的是方式1不管
  37   1              //RB8为0 在方式2或3中表示接收的第9位数据，我们也不管
  38   1              //TI为0 主要用于发送中断请求的标志位
  39   1              //RI为0 用于接收中断的标志位
  40   1          SCON = 0x50;                //8位可变波特率
  41   1              //AUXR是辅助寄存器用来控制定时器的分频
  42   1              //01000000 T1x12为1表示定时器1的速度是传统8051的12倍
  43   1          AUXR = 0x40;                //定时器1为1T模式
  44   1              //TMOD是定时器/计数器的工作模式寄存器，用来控制定时器的操作模式，我们设置的是模式0
  45   1          TMOD = 0x00;                //定时器1为模式0(16位自动重载)
  46   1              //TL1是定时器的低8位，TH1是定时器的高8位，这个定时器主要是用来控制波特率的
  47   1          TL1 = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
  48   1          TH1 = (65536 - (FOSC/4/BAUD))>>8;
  49   1              //TR1为1表示定时器1的控制为，如果为1就表示开始启动定时器
  50   1          TR1 = 1;                    //定时器1开始启动
  51   1              //ES主要是串口中断控制为，如果为1表示允许串口中断
  52   1          ES = 1;                     //使能串口中断
  53   1              //EA表示CPU总的中断允许位，如果为1，那么就表示开放CPU中断
  54   1          EA = 1;
C51 COMPILER V9.60.0.0   SEND                                                              09/06/2020 19:18:49 PAGE 2   

  55   1       //   SendString("STC15F2K60S2\r\nUart Test !\r\n");
  56   1      }
  57          
  58          
  59          /*----------------------------
  60          UART 中断服务程序
  61          interrupt 4表示串口中断
  62          //对于51来说
  63          中断bai0 外部中断0
  64          中断du1 定时器zhi1中断
  65          中断2 外部中断1
  66          中断3 定时器2中断
  67          中断4 串口中断
  68          
  69          using解释
  70          用来选择80c51单片机中不同的寄存器组，你也知道R0-R7总共有4组，那么using 后面的数字也就是0-3范围里的一个数了
             -。如果不需要using的话，编译器会自动选择一组寄存器作为绝对寄存器访问的。
  71          using对代码是有一定的影响的。
  72          给你说个简单的例子，你可以想下，
  73          如果定义 
  74          void time0() interrupt 1 using 1
  75          假设，我们又在中断里调用了一个delay();这个delay是起延时作用。
  76          那么，我们就需要确保我们使用的寄存器组是同一组，否则，就会出现混乱。
  77          -----------------------------*/
  78          void Uart() interrupt 4 using 1
  79          {
  80   1              // 在串口发生中断的时候RI为1表示有数据接收，我们把这位清零用于下次判断
  81   1          if (RI)
  82   1          {
  83   2              RI = 0;                 //清除RI位
  84   2              P0 = SBUF;              //P0显示串口数据
  85   2          }
  86   1              // TI为0表示发送中断，我们主要用来判断当前是否可以发送数据
  87   1          if (TI)
  88   1          {
  89   2              TI = 0;                 //清除TI位
  90   2              busy = 0;               //清忙标志
  91   2          }
  92   1      }
  93          
  94          /*----------------------------
  95          发送串口数据
  96          这个函数用来向串口发送数据
  97          ----------------------------*/
  98          void SendData(BYTE dat)
  99          {
 100   1              // busy判断数据是否发送完毕
 101   1          while (busy);               //等待前面的数据发送完成
 102   1              // 我们用ACC来存放发送的数据
 103   1          ACC = dat;                  //获取校验位P (PSW.0)
 104   1              //P表示奇偶的标志位（当ACC1的个数为奇数的时候P为1反之）。TB8是发送的第9位数据，所以这个是用来校验的
 105   1          if (P)                      //根据P来设置校验位
 106   1          {
 107   2              TB8 = 0;                //设置校验位为0
 108   2          }
 109   1          else
 110   1          {
 111   2              TB8 = 1;                //设置校验位为1
 112   2          }
 113   1              // busy表示需要发送数据，当发送完毕时，会清0
 114   1          busy = 1;
 115   1              // 发需要发送的数据放到寄存器中去
C51 COMPILER V9.60.0.0   SEND                                                              09/06/2020 19:18:49 PAGE 3   

 116   1          SBUF = ACC;                 //写数据到UART数据寄存器
 117   1      }
 118          
 119          /*----------------------------
 120          发送字符串，因为字符串是一个字符数组，所以我们这里是通过指针来发送数据
 121          ----------------------------*/
 122          void SendString(char *s)
 123          {
 124   1          while (*s)                  //检测字符串结束标志
 125   1          {
 126   2              SendData(*s++);         //发送当前字符
 127   2          }
 128   1      }
 129          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     99    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
